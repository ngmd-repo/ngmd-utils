---
keyword: StyleGuidesPage
---

---

### Описание  

В данном руководстве будут описаны основные правила при написании кода в приложениях типа SPA. Это поможет сохранять большую часть кодовой базы проектов компании в едином стиле, обеспечивая простоту миграции разработчиков между проектами и освобождая от возникновения рутинных вопросов.

### Список правил  

1. [Pages](/getting-started/style-guides#pages)
2. [Modules](/getting-started/style-guides#modules)
3. [Features](/getting-started/style-guides#features)
4. [Components](/getting-started/style-guides#components)
5. [Routes](/getting-started/style-guides#routes)
6. [Interfaces](/getting-started/style-guides#interfaces)
7. [Types](/getting-started/style-guides#types)
8. [Enums](/getting-started/style-guides#enums)
9. [Classes](/getting-started/style-guides#classes)
10. [Models](/getting-started/style-guides#models)
11. [API](/getting-started/style-guides#api)
12. [Service](/getting-started/style-guides#service)
13. [State](/getting-started/style-guides#state)
14. [Actions](/getting-started/style-guides#actions)
15. [Store](/getting-started/style-guides#store)
16. [DB](/getting-started/style-guides#db)
17. [Constants](/getting-started/style-guides#constants)
18. [Handlers](/getting-started/style-guides#handlers)
19. [Application](/getting-started/style-guides#application)
20. [Libraries](/getting-started/style-guides#libraries)

### Pages
 
1. Все страницы должны храниться в папке ***./pages***

    1.1 Все корневые страницы должны храниться по пути ***./src/app/pages***
    
    1.2 Все внутренние страницы (роуты), используемые в шаблоне родительского роута, должны храниться по пути ***./{parent-page}/pages/{child-page}***

2. При именовании папки используется `kebab-case`

3. Страницей является компонент, имеющий собственный путь в дереве роутинга

4. Все дочерние компоненты, используемые в шаблоне родительского компонента, должны храниться в папке ***./components***

5. Все внутренние **pages** (роуты) должны повторять структуру хранения файлов корневой директории родительского роута.

6. Все общие типы, сервисы, модели и т.д. для компонентов и дочерних роутов, должны храниться в корне директории родительского роута

7. Каждая страница при необходимости в корне директории должна иметь ***index.ts*** файл, экспортирующий необходимые другим страницам элементы

Пример правильной структуры страницы **documents** с дочерними страницами (роутами) **agreement**, **maf**, **nda**:


![Page](assets/images/getting-started/style-guides/pages.png)

### Modules

1. Модули должны храниться в папке ***./modules***

2. При именовании папки используется `kebab-case`

3. Имя модуля должно иметь название родительского компонента

4. Местом размещения модуля может быть:

    4.1 Директория ***.src/core***, если модуль используется в рамках всего приложения
    
    4.2 Директория ***./modules*** родительской **page**(роута), если модуль используется в рамках страницы и ее потомков

5. Создание модуля может быть обусловлено следующими правилами:

    5.1 Модуль должен иметь собственный компонент, не являющийся отдельной страницей

    5.2 Модуль должен иметь связь с api
    
    5.3 Модуль может использоваться в одном и более местах приложения, изолируя не относящуюся напрямую к месту использования функциональность

6. Модуль должен повторять структуру папок и файлов представленных в этом пособии

7. Если модуль экспортирует сервисы, то необходимо реализовать функцию провайдинга в директории ***./providers/index.ts***. Пример:  

    ```ts name="./providers/index.ts"
    export function provideWeatherModule(): Provider[] {...}
    ```

8. В корне директории модуля должен иметься файл ***./index.ts***, который экспортирует все публичные элементы модуля

Пример модуля **weather**, который используется в рамках **app.component**:

![Modules](assets/images/getting-started/style-guides/modules.png)

### Features

1. Все features должны храниться в папке ***./features***

2. При именование папки используется `kebab-case`

3. При именовании экспортируемого классов-сервиса используется паттерн `{PascalCase}Feature`

4. Местом размещения feature может быть:

    4.1 Директория ***.src/core***, если feature используется в рамках всего приложения

    4.2 Директория ***./features*** родительской **page**(роута), если feature используется в рамках страницы и ее потомков

5. Создание **feature** может быть обусловлено следующими правилами:

    5.1 **feature** <b style="color: #ed4141">НЕ</b> должна иметь собственный компонент

    5.2 **feature** может/должна (в зависимости от контекста) иметь связь с api 

    5.3 **feature** может использоваться в одном и более месте приложения

6. Чаще всего функциональность **feature** реализуется в рамках одного или более сервисов

7. **feature** должен повторять структуру папок и файлов представленных в этом пособии

8. Для экспорта сервисов необходимо реализовать функцию провайдинга в директории ***./providers/index.ts***. Пример:  

      ```ts name="./providers/index.ts"
      export function provideWebsocketFeature(): Provider {...}
      ```

9. В корне директории feature должен иметься файл ***./index.ts***, который экспортирует все публичные элементы


Пример модуля websocket, который инициализируется в рамках app.component:

![Features](assets/images/getting-started/style-guides/features.png)

### Components
 

1. Все компоненты должны храниться в папке ***./components***

2. Если в декораторе компонента в поле imports или providers более 2-ух импортируемых сущностей, нужно вынести их в ***./imports/index.ts***

3. Для именования массивов imports и providers используется `{PascalCase}Imports` и `{PascalCase}Providers`, соответственно: 

    ```ts name="./imports/index.ts"
      import { Provider, Type } from '@angular/core';
      import { RouterOutlet } from '@angular/router';

      export const ExampleComponentImports: Type<unknown>[] = [RouterOutlet];
      
      export const ExampleComponentProviders: Provider[] = [SomeService];
    ```

4. Все поля компонента, используемые в шаблоне, должны иметь модификатор доступа `protected`, если они не используются при референции на компонент через `viewChild`, `contentChild` и т.д.

5. Все поля, не используемые в шаблоне, должны иметь модификатор доступа `private`, если они не используются при наследовании.

6. Все вложенные компоненты должны лежать в папке ***./components***, родительского компонента и иметь всегда идентичную структуру папок.

Пример правильной структуры компонента ***./components/modal-popup***:

![Components](assets/images/getting-started/style-guides/components.png)

### Routes

1. Файл роутов должен храниться в папке ***./routes***

2. Папка ***./routes*** должна находиться в корне родительского компонента этого роута

3. Имя файла должно быть ***index.ts***

4. Для именования массива роутов используется паттерн `{PascalCase}Routes`

5. Если в роуте в поле **providers** зарегистрировано более 2-ух сервисов, их необходимо поместить в константу c именем `{PascalCase}RouteProviders` в текущем файле роутов

6. Все поля **children** в объекте роута, должны быть импортируемыми массивами из директорий их корневых модулей.

7. Все дочерние роуты должны повторять идентичную структуру

Пример правильного создания **routes**:

```ts name="./routes/index.ts"
import { SomePageChildrenRoutes, somePageRouteProviders } from '../pages/some-page';

const AppRouteProviders: (EnvironmentProviders | Provider)[] = [AppService, AnotherAppService];

export const appRoutes: Routes  = [
  { 
    path: '', 
    component: AppComponent, 
    providers: AppRouteProviders,
  },
  { 
    path: 'some-page', 
    loadComponent: () => import("../pages/some-page/some-page.component").then(({ SomePageComponent }) => SomePageComponent), 
    children: SomePageChildrenRoutes, 
    providers: somePageRouteProviders() 
  },
];
```

### Interfaces

1. Все интерфейсы должны храниться в папке ***./interfaces***

2. При именовании файла используется паттерн `{kebab-case}.interface.ts`

3. При именовании интерфейса используется паттерн `I{PascalCase}`

4. Уровни хранения интерфейсов определяются уровнями вложенности компонентов:

    4.1 Если интерфейс используется в параллельных компонентах, он должен храниться в корне родительского компонента.

    4.2 Если интерфейс используется только в компоненте и/или его потомках, то он должен храниться в корне  этого компонента

5. Создание интерфейса оправданно в следующих случаях:

    5.1 Если описываемые данные приходят или отправляются по API

    5.2 Если интерфейс имплементируется множественными сущностями типа [Classes](/getting-started/style-guides#classes) или [Models](/getting-started/style-guides#models)

    5.3 Если интерфейс описывает функциональность любого `InjectionToken` (директивы, компонента, пайпа, сервиса и т.д.)

6. Объявление интерфейса всегда должно идти в начале файла. Составляющие части по типу enums, types и т.д. должны располагаться ниже объявления родительского интерфейса. Это позволяет при открытии файла сразу сконцентрироваться на основной сущности.

Пример правильного создания интерфейса:

```ts name="./interfaces/user.interface.ts"
  export interface IUser {
    id: string;
    status: TUserStatus;
    role: EnUserRole;
  }

  export type TUserStatus = "active" | "disabled";

  export const enum EnUserRole {
    DEFAULT,
    ADMIN
  }
```

### Types

1. Файлы с типами должны храниться в папке ***./types***

2. Именование файла должно придерживаться следующих правил:

    2.1 Если файл один - ***index.ts***

    2.2 Если более одного файла - `{kebab-case}.types.ts`

3. При именовании типа используется паттерн `T{PascalCase}`

4. Условия хранения типов:

    4.1 Если тип используется только в компоненте и его потомках, он должен храниться в рамках своего компонента.

    4.2 Если тип используется в параллельных по уровню вложенности компонентах, он должен храниться в рамках родительского компонента.

    4.3 Если тип относится только к сущности типа [Classes](/getting-started/style-guides#classes), [Models](/getting-started/style-guides#models), [Interfaces](/getting-started/style-guides#interfaces), [States](/getting-started/style-guides#states), то он должен храниться в файле своей сущности

5. Типы <b style="color: #ed4141">НЕ</b> должны использоваться при взаимодействии с API (в подавляющем большинстве случаев)

Пример правильного хранения типов:

```ts name="./types/index.ts"
  export type THeaderConfig = {
    title: string;
    description: string;
  }

  export type TNavOption = {
  url: string;
  title: string;
  }

  export type TNavOptions = TNavOption[];
```

### Enums

1. Файлы c enums должен храниться в папке ***./enums***

2. Именование файла должно придерживаться следующих правил:

    2.1 Если файл один - ***index.ts***
    
    2.2 Если более одного файла - `{kebab-case}.enum(s).ts`

3. Условия хранения enums:

    3.1 Если enum используется только в компоненте и его потомках, он должен храниться в рамках своего компонента.

    3.2 Если enum используется в параллельных по уровню вложенности компонентах, он должен храниться в рамках их родительского компонента.

    3.3 Если enum относится только к сущности типа [Classes](/getting-started/style-guides#classes), [Models](/getting-started/style-guides#models), [Interfaces](/getting-started/style-guides#interfaces), [States](/getting-started/style-guides#states), то он должен храниться в файле своей сущности

4. Все enum должны объявляться через `const`

5. Все поля enum должны использовать нотацию `SNAKE_UPPER_CASE`

6. При именовании enum используется паттерн `En{PascalCase}`

Пример правильного создания **enum**:

```ts name="./enums/index.ts"
  export const enum EnMessageState {
    FAILED,
    WARNING,
    SUCCESS
  }
  export const enum EnSomeType = {
    SOME_TYPE,
    ANOTHER_SOME_TYPE
  }
```

### Classes
 
1. Файлы классов должны храниться в папке ***./classes***

2. При именование файла используется паттерн `{kebab-case}.class.ts`

3. При именовании класса используется паттерн `PascalCase`

4. Условия хранения классов:

    4.1 Если класс используется только в компоненте и его потомках, он должен храниться в рамках своего компонента.

    4.2 Если класс используется в параллельных по уровню вложенности компонентах, он должен храниться по пути в рамках их родительского компонента.

5. Объявление класса всегда должно идти в начале файла. Составляющие части по типу enums, types и т.д. должны располагаться ниже объявления родительского класса.

6. Создание класса оправданно в следующих случаях:

    6.1 Если в классе реализуется логика по работе, хранению, мапингу, менеджменту и т.д. различных данных (к примеру, скрывает в себе реализацию по работе с данными пошаговой формы)

    6.2 Если класс изолирует в себе определенный набор семантически связанной функциональности (к примеру, реализует набор методов для валидации форм)

Пример правильного использования класса:

```ts name="./classes/form-pattern.class.ts"
export class FormPattern {

  public static get NUMBERS(): RegExp {
    return new RegExp(/^[0-9]+$/);
  }

  public static get HTTP_URL(): RegExp {
    return new RegExp(/^(https?:\/\/)?([a-z0-9-]+[.]{1}){1,3}\w{2,10}$/i);
  }

  public static get EMAIL(): RegExp {
    return new RegExp(
      /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/,
    );
  }
  // ...
}
```

### Models
 
1. Файлы моделей должны храниться в папке ***./models***

2. При именование файла используется паттерн **{kebab-case}.model.ts**

3. При именовании класса используется паттерн `PascalCase`

4. Условия хранения моделей:

    4.1 Если модель используется только в компоненте и его потомках, она должен храниться в рамках своего компонента.

    4.2 Если модель используется в параллельных по уровню вложенности компонентах, она должна храниться в рамках их родительского компонента.

5. Объявление моделей всегда должно идти в начале файла. Составляющие части по типу enums, types и т.д. должны располагаться ниже объявления родительской модели.

6. Создание модели оправданно в следующих случаях:

    6.1 Если описываемые данные приходят или отправляются по API, но при подготовке данных требуется минимальная логика (к примеру модификация входящих значений при создании экземпляра класса, использование значений по умолчанию) 

    6.2 Если описываемым данным требуются те же условия, что и в пункте 4.1, без привязки к API (так же примером может быть геттер-метод, который преобразовывает хранимые в модели данные в требуемый вид)

Пример правильного использования модели:

```ts name="./models/form-range.model.ts"
export class FormRange {
  constructor(
    public from: number,
    public to: number,
  ) {}

  public getRangePercents(): string {
    const { from, to } = this;

    return `${from}-${to}`;
 }
}
```

### API

1. Для работы с **API** использует модуль [**@ngmd/utils/http**](/http)

2. ApiHub должен храниться в папке происходит в папке ***./api***

3. Именование файла с **ApiHub** должно придерживаться следующих правил:

    3.1 Если файл один - ***index.ts***

    3.2 Если более одного файла - `{kebab-case}.api-hub.ts`

4. Имя класса **ApiHub** должно придерживаться паттерна ***{PascalCase}ApiHub***:

    ```ts name="./api/index.ts"
    export class UsersApiHub {
      public getUsers$: GetRequest<IUser[]> = useGet("@/users"); 
    }
    ```

5. Имя переменной **ApiHub** при использовании в компоненте должно иметь финскую нотацию и придерживаться паттерна `{camelCase}Hub$` :

    ```ts
    public usersHub$: ApiHub<UsersApiHub> = useApiHub(UsersApiHub);
    ```


6. При создании запроса, имя переменной должно иметь финскую нотацию:

    ```ts
    public getUsers$: GetRequest<IUser[]> = useGet("@/users");
    ```

7. Для создания параметров urlOptions всегда используется тип `UrlOptions`

8. urlOptions можно создавать:

  8.1 В компонентах если эти типы не экспортируются

  8.2 В рамках файла **ApiHub** под определением класса, в папке ***./types/index.ts***, если типы экспортируются 

### Service

1. Файл сервиса должен храниться в папке **./services** 

2. Именование файла  должно придерживаться следующих правил:

    2.1 Если файл один - **index.ts**

    2.2 Если более одного файла - `{kebab-case}.service.ts`

3. При именовании класса используется паттерн `{PascalCase}Service`

4. Сервисом могут обладать следующие сущности:

    4.1 [Page](/getting-started/style-guides#pages)

    4.2 [Module](/getting-started/style-guides#modules)

    4.3 [Feature](/getting-started/style-guides#features)

    4.4 [Component](/getting-started/style-guides#components)

5. Условия хранения сервисов:

    5.1 Если сервис используется в компоненте и его потомках, она должен храниться в рамках своего компонента.

    5.2 Если сервис используется в параллельных по уровню вложенности компонентах, он должен храниться в рамках их родительского компонента.

    5.3 Если сервис используется в сущностях, отличных от компонента, он должен храниться в корневой директории своей сущности

6. **Service** может иметь свой набор [Actions](/getting-started/style-guides#actions)

7. Задачи **Service** могут быть следующими:

    7.1 Обеспечить связь между родительским и дочерними компонентами при помощи общих состояний и методов

    7.2 Реализовать в себе логику вызовов и обработки api запросов

    7.2 Изолировать контекстную логику в рамках сущности, которой принадлежит сервис

8. Все дочерние сущности могут инжектировать сервис родительской сущности 

9. Для возвращения сервиса к дефолтному состоянию, в зависимости от контекста, должны использоваться методы `ngOnDestroy` или `destroy`

Пример правильно созданного файла service, принадлежащего компоненту:

![Service](assets/images/getting-started/style-guides/service.png)

### State

1. Для работы с состояниями используется модуль [**@ngmd/utils/state**](/state)

2. Файл с состояниями должен храниться по пути ***./state***

3. Именование файла  должно придерживаться следующих правил:
    3.1 Если файл один - **index.ts**
    3.2 Если более одного файла -  **{kebab-case}.state.ts**

4.При именовании класса используется паттерн **{PascalCase}State**

5. При именовании поля в компоненте используется паттерн **{camelCase}State**

Пример правильно созданного файла **state**:

```ts name="./state/index.ts"
import { TShowState } from '@ngmd/utils/types';

export class UsersState {
  public editModalVisibleState: TShowState = 'hide';
  public isUserActive: boolean = false;
}
```

### Actions

1. Для работы со событиями используется модуль [**@ngmd/utils/actions**](/actions)

2. Файл с событиями событий должен храниться в папке  ***./actions***

3. Именование файла  должно придерживаться следующих правил:
    3.1 Если файл один - либо **index.ts**
    3.2 Если более одного файла - **{kebab-case}.actions.ts**

4. При именовании типа для списка событий используется паттерн **T{PascalCase}Actions**

5. При именовании строкового типа события используется паттерн `kebab-case`

6. При именовании токена доступа событий используется паттерн  **{SNAKE_CASE}_ACTIONS**

7. При именовании переменной в компоненте используется паттерн **{camelCase}Actions$**

Пример правильно созданного файла со списком событий:


```ts name="./actions/index.ts"
export type TModalActions =
  | ChannelAction<'hide-modal'>
  | ChannelAction<'show-modal', boolean>
  | ChannelAction<'toggle-modal', TShowState>; // список событий

export const MODAL_ACTIONS = ActionsChannelToken<TModalActions>('MODAL'); // токен 
```

### Store
 
1. Для работы со хранилищем используется модуль [**@ngmd/utils/store**](/store)

2. Файл с хранилищем должен храниться в папке ***./store***

3. Именование файла  должно придерживаться следующих правил:
    3.1 Если файл один - **index.ts**
    3.2 Если более одного файла -  **{kebab-case}.store.ts**

4. При именовании класса используется паттерн **{PascalCase}Store**

5. При именовании поля в компоненте используется паттерн **{camelCase}Store**

6. ore может использоваться только для хранения данных, которые приходят по api

Пример правильно созданного файла хранилища:


```ts name="./store/index.ts"
import { IUser } from '../interface/user.interface';

export class UsersStore {
  public users: IUser[] = null;
  public user: IUser = null;
}
```

### DB
 
1. Для работы со статическими данными должен использоваться модуль [**@ngmd/utils/db**](/db)

2. Файл с данным должен храниться по пути ***./db***

3. Именование файла  должно придерживаться следующих правил:
    3.1 Если файл один - **index.ts**
    3.2 Если более одного файла -  **{kebab-case}.db.ts**

4. При именовании объекта используется паттерн **{PascalCase}DB** 

5. Все статические данные, используемые в бизнес логике приложения, должны храниться в **db**

6. Для именования ключей с данными, которые относятся к определенному компоненту, предпочтительно создать ключ с именем компонента и значением в виде объекта, в котором будут лежать данные, касающиеся только этого компонента

Пример правильного хранения статических данных:


```ts name="./db/index.ts"
export const ExampleDB = {
  header: {
    default: {
      title: 'Default title',
      description: 'Default description'
    },
    security: {
      title: 'Security title',
      description: 'Security description'
    }
    //...
  },
  footer: {
    options: [
      new FooterOption(/*...*/),
      new FooterOption(/*...*/),
      new FooterOption(/*...*/)
    ]
  }
  //...
} as const; // использование as const опционально
```

### Constants

1. Файл с константами должен храниться в папке **./constants**

2. Именование файла  должно придерживаться следующих правил:

    2.1 Если файл один - **index.ts**

    2.2 Если более одного файла - `{kebab-case}.constants.ts`

3. При именовании констант используется паттерн `{SNAKE_UPPER_CASE}`

4. Для хранения технических или строгих константных значений в библиотеках или приложениях допускается использование констант, если значения необходимо изолировать от хранения в [DB](/getting-started/style-guides#db) или [Enums](/getting-started/style-guides#enums).

### Handlers

1. Файл c обработчиками должен храниться в папке **./handlers**

2. Именование файла  должно придерживаться следующих правил:

    2.1 Если файл один - либо **index.ts**

    2.2 Если более одного файла -  `{kebab-case}.handlers.ts`

3. Для изоляции определенной логики так же допускается создание и использование функций хелперов, которые реализуют рутинную повторяющуюся логику, во многих частях приложения.

4. При выборе хранения стоит опираться на следующие правила:
    4.1 Если функция используется в рамках всего приложения, тогда ее нужно хранить по пути ***./app/core/handlers/index.ts***. Если кол-во хелперов велико, можно прибегнуть к контекстному именованию: ***string.handlers.ts***, ***condition.handlers.ts*** и т.д. В таком случае **index.ts** будет реэкспортировать функциональность данных файлов.

    4.2 Если функция используется только в определенной сущности и/или его потомках, тогда ее нужно хранить в рамках корневой директории своей сущности

Пример директории **handlers** для всего приложения ***./app/core/handlers***:


![Handlers](assets/images/getting-started/style-guides/handlers.png)
 

И функциональностью на примере файла **string.handlers.ts**:

```ts name="./handlers/string.handlers.ts"
export function titlecase<T extends string>(str: T): Capitalize<T> {
  // ...
}
export function prefix(str: unknown, tag: string): string {
  // ...
}
// ...
```

### Application
 

Все продуктовые приложения:

1. Должны иметь префикс `ng`

2. Должны использовать `scss` в качестве инструмента стилизации

3. Должны быть `standalone`

4. Использовать `OnPush` стратегию

5. Для хранения максимально общих частей приложения (компонентов, пайпов, директив и т.д.) нужно использовать директорию ***./app/core*** с alias тегом `@core`, указанным в поле `paths` файла ***tsconfig.json***. Так же каждый модуль должен иметь файл **index.ts** экспортирующий необходимые сущности.

Пример корректно структурированной папки ***./src/app/core***:

![Application Core](assets/images/getting-started/style-guides/application-core.png)

### Libraries

Все библиотеки:

1. Должны иметь префикс имени библиотеки (в сокращенной форме при большом количестве символов) 

2. Должны использовать `scss` в качестве инструмента стилизации

3. Должны быть `standalone`

4. Использовать `OnPush` стратегию

5. Иметь экспортируемую provide функцию для внедрения в приложения-потребители (к примеру `provideSomeLibrary()`)

6. Экспортировать только функциональность, предназначенную для внешнего использования